<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/12/b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/12/b/" itemprop="url">b</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-12T19:01:12+08:00">
                2020-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="//yoursite.com/2020/01/12/b/%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB.png" alt="三者关系"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/12/a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/12/a/" itemprop="url">a</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-12T18:59:46+08:00">
                2020-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/08/搭建腾讯云https网络服务器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/08/搭建腾讯云https网络服务器/" itemprop="url">搭建腾讯云https网络服务器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-08T13:36:34+08:00">
                2019-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一-购买域名"><a href="#一-购买域名" class="headerlink" title="一.购买域名"></a>一.购买域名</h2><p>进入腾讯云官网,用微信登录账号(若提示是否创建新账号,点击创建新账号)往下翻,找到<code>域名与网站</code>功能菜单,点击</p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/1.png"></p>
<p>点击域名注册</p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/2.png"></p>
<p>点击<code>域名1元抢</code></p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/3.png"></p>
<p>进入页面后<code>.club</code>和<code>.xyz</code>域名都是一年一元,按喜好任选即可</p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/4.png"></p>
<p>点击之后,再输入框中输入自己的想要创建的域名,点击查询,如果不可以购买,说明已被抢注,需要换其他名称</p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/5.png"></p>
<p>购买完成之后,点击页面右上角控制台,即可进入管理中心,看到自己购买的域名</p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/6.png"></p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/7.png"></p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/8.png"></p>
<p>之后,在该页面点击实名认证,域名都要通过实名认证才可以使用,填写相关信息即可</p>
<h2 id="二-购买服务器"><a href="#二-购买服务器" class="headerlink" title="二.购买服务器"></a>二.购买服务器</h2><p>接下来准备购买服务器,在腾讯云官网有15天免费体验,可以先进行试用</p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/9.png"></p>
<p>这一部分都可以免费试用,我们主要需要<code>云服务器</code></p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/10.png"></p>
<p>点击领取之后会有默认配置可以选择,操作系统的话,如果熟悉Linux可以使用Cent OS,否则选择windows server即可</p>
<p>接下来免费付款即可</p>
<p>完成之后,右上角会有消息提示,点击查看消息,即可看到购买的服务器的登录密码和相关信息</p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/11.png"></p>
<h2 id="三-服务器配置"><a href="#三-服务器配置" class="headerlink" title="三.服务器配置"></a>三.服务器配置</h2><p>接下来需要配置服务器</p>
<p>1.首先登录云服务器控制台</p>
<p>2.在实例列表中可以看到自己的服务器,点击登录</p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/12.png"></p>
<p>3.在弹出的【登录Windows实例】窗口中，选择【使用 RDP 文件登录】，单击【下载 RDP 文件】到本地。</p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/13.png"></p>
<p>4.双击下载到本地的 RDP 文件，远程连接到 Windows 云服务器。</p>
<p>到此服务器基本设置完成,接下来需要在服务器中安装node,sublime等等(强烈推荐vscode)</p>
<h2 id="四-域名配置"><a href="#四-域名配置" class="headerlink" title="四.域名配置"></a>四.域名配置</h2><p>在完成实名认证后,点击控制台,进入域名管理,点击解析</p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/14.png"></p>
<p>点击添加记录,基本格式按以下图片内容写</p>
<p><strong>注意:其中记录值换成你自己购买的服务器的公网ip</strong></p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/15.png"></p>
<p>这样域名已经与服务器进行绑定</p>
<h2 id="五-https连接测试"><a href="#五-https连接测试" class="headerlink" title="五.https连接测试"></a>五.https连接测试</h2><p>以下都是在云服务器中操作</p>
<p>1.要搭建https的连接,先要下载ssl证书管理,在腾讯云官网中,点击控制台,云产品,ssl证书</p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/16.png"></p>
<p>2.点开之后会看到如下</p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/17.png"></p>
<p>3、点击申请证书，默认选择即可</p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/18.png"></p>
<p>4、填写信息完毕后，选择“自动DNS验证”，将自动为域名添加DNS记录，如下图：</p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/19.png"></p>
<p>5、等候证书通过，通过后点击下载</p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/20.png"></p>
<p>6、然后把这两个文件放到服务器磁盘中(新建一个usr文件夹,放入其中,记住他的绝对路径)</p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/21.png"></p>
<p>7.在服务器中安装Nginx,进行反向代理,这是Nginx的官网</p>
<p><a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a></p>
<p>下载解压即可</p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/22.png"></p>
<p>7、修改Nginx下面的conf文件夹下nginx.conf文件添加如下代码,删去中文</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen              <span class="number">443</span> ssl;</span><br><span class="line">    server_name         gw2.vsgames.cn;</span><br><span class="line">    ssl_certificate     /Users/wucao/Desktop/gw2.vsgames.cn/Nginx/<span class="number">1</span>_gw2.vsgames.cn_bundle.crt;  <span class="comment"># 证书文件地址</span></span><br><span class="line">    ssl_certificate_key /Users/wucao/Desktop/gw2.vsgames.cn/Nginx/<span class="number">2</span>_gw2.vsgames.cn.key; <span class="comment"># 私钥文件地址</span></span><br><span class="line">    ssl_protocols       TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    ssl_ciphers         HIGH:!aNULL:!MD5;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置好点击nginx.exe重启Nginx</p>
<p>8.接下来在node中编写代码,将秘钥和证书地址改为自己的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  key: fs.readFileSync(<span class="string">'/Users/wucao/Desktop/gw2.vsgames.cn/Nginx/2_gw2.vsgames.cn.key'</span>),<span class="comment">//秘钥地址</span></span><br><span class="line">  cert: fs.readFileSync(<span class="string">'/Users/wucao/Desktop/gw2.vsgames.cn/Nginx/1_gw2.vsgames.cn_bundle.crt'</span>)<span class="comment">//证书地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">https.createServer(options, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.statusCode = <span class="number">200</span>;</span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>);</span><br><span class="line">  res.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;).listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure>

<p>开启服务器</p>
<p>输入你的域名地址加端口号,例如<code>https://uniquezhou.xyz:8000</code></p>
<p>出现<code>hello world</code>说明搭建成功</p>
<p><img src="D:/web/9.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E8%85%BE%E8%AE%AF%E4%BA%91https%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/images/23.png"></p>
<p>若直接域名访问,则将监听端口设为80即可</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/22/Vue小技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/22/Vue小技巧/" itemprop="url">Vue小技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-22T10:11:00+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、-js适配经验："><a href="#一、-js适配经验：" class="headerlink" title="一、 js适配经验："></a>一、 js适配经验：</h2><p>在写代码的时候，很有可能写到这种代码： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5].includes(1)</span><br></pre></td></tr></table></figure>

<p>或者是使用promise等es6的方法，但是我们的需求是在Android4.4上面完美运行。这样就会出现includes is not undefied等错误提示。我们可以通过webpack的插件来解决，具体的使用方法：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &quot;babel-polyfill&quot;</span><br><span class="line">import es6Promise from &apos;es6-promise&apos;</span><br><span class="line">es6Promise.polyfill()</span><br><span class="line">require(&apos;es6-promise&apos;).polyfill()</span><br><span class="line"></span><br><span class="line">// webpack配置文件处</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: [&apos;babel-polyfill&apos;, &apos;./src/main.js&apos;]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h2 id="二、-全局定义"><a href="#二、-全局定义" class="headerlink" title="二、 全局定义"></a>二、 全局定义</h2><p>当我们写了很多库的时候，我们引入页面可能会变成这样： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// vue 1</span><br><span class="line">import utils from &quot;library&quot;</span><br><span class="line">// vue 2</span><br><span class="line">import utils from &quot;library&quot;</span><br><span class="line">...</span><br><span class="line">// vue n</span><br><span class="line">import utils from &quot;library&quot;</span><br></pre></td></tr></table></figure>

<p>可以这样处理 ，这样会节省很多没有必要的代码量 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import http from &quot;http/http&quot;</span><br><span class="line">Vue.prototype.$okhttp = http</span><br><span class="line"></span><br><span class="line">// use</span><br><span class="line">this.$okhttp</span><br></pre></td></tr></table></figure>

<h2 id="三、-自定义目录"><a href="#三、-自定义目录" class="headerlink" title="三、 自定义目录"></a>三、 自定义目录</h2><p>在写代码的时候，很多时候都存在这种情况 ： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样写的缺陷是一旦某个目录发生变化就会导致引入错误。可以通过webpack路径解决 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在resolve-&gt;alias里面可以配置绝对相对路径，在使用的时候 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="四、-路由懒加载"><a href="#四、-路由懒加载" class="headerlink" title="四、 路由懒加载"></a>四、 路由懒加载</h2><p>官方文档里面定义路由的时候都有两步： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在做大型项目的时候 很可能定义很多很多个路由，那样页面就会写的特别多。此时懒加载就会解决这个问题  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Router from &apos;vue-router&apos;</span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">const router = new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      component: () =&gt; import(&quot;xxx&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="五、-样式污染和样式覆盖的问题"><a href="#五、-样式污染和样式覆盖的问题" class="headerlink" title="五、 样式污染和样式覆盖的问题"></a>五、 样式污染和样式覆盖的问题</h2><p>在我们新建vue的时候，经常会看到<code>scoped</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>如果我们去掉scoped的时候会发现，在本vue项目内定义的css属性会影响到其他vue页面的css属性。这个就很坑了。所以，我们在使用的时候一定要用scoped 但是在实际的开发中，也会遇到这么个问题。比如elementUI](<a href="http://element-cn.eleme.io/#/zh-CN/component/changelog)，虽然里面的资源库很强大，但是里面的视图不能完全符合策划的需求，此时就需要进行微调。" target="_blank" rel="noopener">http://element-cn.eleme.io/#/zh-CN/component/changelog)，虽然里面的资源库很强大，但是里面的视图不能完全符合策划的需求，此时就需要进行微调。</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;</span><br><span class="line">  .custom-dialog</span><br><span class="line">    .el-dialog__header</span><br><span class="line">      padding 0</span><br><span class="line">    .el-dialog__body</span><br><span class="line">      padding 0</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p> 如果此时我们加上scoped标签的话，我们发现并没有效果，发现去掉scoped才会起作用。</p>
<h2 id="六、-mock、mock"><a href="#六、-mock、mock" class="headerlink" title="六、 mock、mock"></a>六、 mock、mock</h2><p>很多情况下，后台还没有搭建完成之前。可能前端没办法进行数据的接入。这种情况可能是一个大问题，这样会严重拖慢项目开发，此时就需要mock 首先在webpack.dev.conf.js里面配置express</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;)</span><br><span class="line">const app = express()</span><br><span class="line">const appData = require(&apos;../static/data/user.json&apos;)</span><br><span class="line">const apiRouter = express.Router()</span><br><span class="line">app.use(&apos;/api&apos;,apiRouter)</span><br></pre></td></tr></table></figure>

<p>然后将接口通过<code>devServer</code>发布出去: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> before(app) &#123;</span><br><span class="line">  app.get(&apos;/api/user&apos;,(req, res) =&gt; &#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">      data: appData</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候就直接打开<a href="http://localhost:8080/api/user,就可以了。" target="_blank" rel="noopener">http://localhost:8080/api/user,就可以了。</a></p>
<h2 id="七、-代理解决跨域"><a href="#七、-代理解决跨域" class="headerlink" title="七、 代理解决跨域"></a>七、 代理解决跨域</h2><p>有些时候，在进行本地开发的时候，可能会遇到跨域的问题。为了解决这个问题呢？主要有两种方法： 1、 服务器设置 服务端设置很简单，就是将本地开发的东西加上“Access-Control-Allow-Origin”, “*”,或者是直接将本地开发的ip直接设置成白名单，这样就可以了. 2、 本地代理 </p>
<p>首先引入  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install http-proxy-middleware --save</span><br></pre></td></tr></table></figure>

<p>然后在<code>index.js</code>的标签下<code>proxyTable</code>使用 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&apos;/lesson&apos;: &#123;</span><br><span class="line">        target: &apos;http://xxx/v2/webapi/lesson&apos;, // 代理的网址</span><br><span class="line">        changeOrigin: true, // 允许跨域</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">         &apos;^/lesson&apos;: &apos;/&apos;</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候，就直接使用 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">       method: &apos;get&apos;,</span><br><span class="line">       url:&apos;/lesson&apos; ,</span><br><span class="line">       params: qs.stringify(data)</span><br><span class="line">     &#125;).then(function (res) &#123;</span><br><span class="line">       if (res) &#123;</span><br><span class="line">         //...</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;).catch(function (error) &#123;</span><br><span class="line">     console.error(error);</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="八、-页面统一判断"><a href="#八、-页面统一判断" class="headerlink" title="八、 页面统一判断"></a>八、 页面统一判断</h2><p>在开发中经常会遇到权限判断的问题，我们又不可能在每一个页面的生命周期中去判断一下，可以这样处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  myAccess.checkhaveAccess(to.path) === true ? next() : next(&apos;/forbid&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="九、-事件的传递："><a href="#九、-事件的传递：" class="headerlink" title="九、 事件的传递："></a>九、 事件的传递：</h2><p>一般来说事件的传递有很多种，比如父子之间传递数据就可以直接用props，和emit来做关联。</p>
<p>父组件给子组件传递  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;child :datas=&quot;content&quot;&gt;&lt;/child&gt; </span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        content:&apos;sichaoyun&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line"></span><br><span class="line">props:[&quot;datas&quot;];</span><br><span class="line">// 或者是 </span><br><span class="line">props: &#123;</span><br><span class="line"> datas: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子组件给父组件传递 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div @click=&quot;open&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">   open() &#123;</span><br><span class="line">        this.$emit(&apos;showbox&apos;,&apos;the msg&apos;); //触发showbox方法，&apos;the msg&apos;为向父组件传递的数据</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 父组件</span><br><span class="line">&lt;child @showbox=&quot;toshow&quot; :msg=&quot;msg&quot;&gt;&lt;/child&gt; //监听子组件触发的showbox事件,然后调用toshow方法</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">    toshow(msg) &#123;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>兄弟组件之间的传递一般有几种方式： 1、 注册全局事件 2、 vuex 3、 localstorage </p>
<p>使用全局事件则代码如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let vm = new Vue(); //创建实例</span><br><span class="line"></span><br><span class="line">&lt;div @click=&quot;ge&quot;&gt;&lt;/div&gt;</span><br><span class="line">methods: &#123;</span><br><span class="line">    ge() &#123;</span><br><span class="line">        vm.$emit(&apos;click&apos;,data); //触发事件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">created() &#123;</span><br><span class="line">  vm.$on(&apos;click&apos;, (arg) =&gt; &#123; </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十、-列表渲染"><a href="#十、-列表渲染" class="headerlink" title="十、 列表渲染"></a>十、 列表渲染</h2><h3 id="v-for循环绑定model"><a href="#v-for循环绑定model" class="headerlink" title="v-for循环绑定model:"></a>v-for循环绑定model:</h3><p>这个是我在一个微信公众号上面看到的写法，很新颖: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 数据    </span><br><span class="line">     data() &#123;</span><br><span class="line">         return&#123;</span><br><span class="line">          obj: &#123;</span><br><span class="line">             ob: &quot;OB&quot;,</span><br><span class="line">             koro1: &quot;Koro1&quot;</span><br><span class="line">           &#125;,</span><br><span class="line">           model: &#123;</span><br><span class="line">             ob: &quot;默认ob&quot;,</span><br><span class="line">             koro1: &quot;默认koro1&quot;</span><br><span class="line">           &#125;   </span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">   // html模板</span><br><span class="line">   &lt;div v-for=&quot;(value,key) in obj&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;model[key]&quot;&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">     // input就跟数据绑定在一起了，那两个默认数据也会在input中显示</span><br></pre></td></tr></table></figure>

<h3 id="v-if尽量不要与v-for在同一节点使用"><a href="#v-if尽量不要与v-for在同一节点使用" class="headerlink" title="v-if尽量不要与v-for在同一节点使用:"></a>v-if尽量不要与v-for在同一节点使用:</h3><p>v-for 的优先级比 v-if 更高,如果它们处于同一节点的话，那么每一个循环都会运行一遍v-if。</p>
<p> 如果想根据循环中的每一项的数据来判断是否渲染，可以这么做: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;index in datas&quot; v-if=&quot;Object.is(index,0)&quot;&gt;</span><br><span class="line">  &#123;&#123; index &#125;&#125;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>

<p>如果你想要根据某些条件跳过循环，而又跟将要渲染的每一项数据没有关系的话，可以将v-if放在v-for的父节点： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 根据elseData是否为true 来判断是否渲染，跟每个元素没有关系    </span><br><span class="line">    &lt;ul v-if=&quot;condition&quot;&gt;</span><br><span class="line">     &lt;li v-for=&quot;index in datas&quot;&gt;</span><br><span class="line">       &#123;&#123; index &#125;&#125;</span><br><span class="line">     &lt;/li&gt;</span><br><span class="line">   &lt;/ul&gt;</span><br><span class="line">   // 数组是否有数据 跟每个元素没有关系</span><br><span class="line">   &lt;ul v-if=&quot;datas.length&quot;&gt;</span><br><span class="line">     &lt;li v-for=&quot;index in datas&quot;&gt;</span><br><span class="line">       &#123;&#123; index &#125;&#125;</span><br><span class="line">     &lt;/li&gt;</span><br><span class="line">   &lt;/ul&gt;</span><br><span class="line">     &lt;p v-else&gt;没有更多数据&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h2 id="十一、-深度watch与watch立即触发回调"><a href="#十一、-深度watch与watch立即触发回调" class="headerlink" title="十一、 深度watch与watch立即触发回调"></a>十一、 深度watch与watch立即触发回调</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch有两个可选参数</span><br><span class="line">选项：deep</span><br><span class="line">在选项参数中指定 deep: true，可以监听对象中属性的变化。</span><br><span class="line">选项：immediate</span><br><span class="line">在选项参数中指定 immediate: true, 将立即以表达式的当前值触发回调，也就是默认触发一次。</span><br></pre></td></tr></table></figure>

<h2 id="十二、-路由的项目启动页和404页面"><a href="#十二、-路由的项目启动页和404页面" class="headerlink" title="十二、 路由的项目启动页和404页面"></a>十二、 路由的项目启动页和404页面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: &apos;/&apos;, // 项目启动页</span><br><span class="line">        redirect:&apos;/login&apos;  // 重定向到下方声明的路由 </span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: &apos;*&apos;, // 404 页面 </span><br><span class="line">        component: () =&gt; import(&apos;./notfind&apos;)</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>比如你的域名为:<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 项目启动页指的是: 当你进入<a href="http://www.baidu.com，会自动跳转到login登录页。" target="_blank" rel="noopener">www.baidu.com，会自动跳转到login登录页。</a> 404页面指的是: 当进入一个没有 声明/没有匹配 的路由页面时就会跳转到404页面。 比如进入<a href="http://www.baidu.com/testRouter,就会自动跳转到notFind页面。" target="_blank" rel="noopener">www.baidu.com/testRouter,就会自动跳转到notFind页面。</a> 当你没有声明一个404页面，进入<a href="http://www.baidu.com/testRouter，显示的页面是一片空白。" target="_blank" rel="noopener">www.baidu.com/testRouter，显示的页面是一片空白。</a> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/05/请求方法的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/05/请求方法的理解/" itemprop="url">请求方法的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-05T12:48:28+08:00">
                2019-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a><strong>XMLHttpRequest</strong></h2><p>XMLHttpRequest是最早出现的与服务器交换数据的方案，有了XMLHttpRequest，开发者终于可以在不重新加载页面的情况下更新网页，可以在页面加载后请求接受以及发送数据。而所有浏览器均可以获取XMLHttpRequest对象：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest(); //获取xhr对象</span><br></pre></td></tr></table></figure>

<p>但是XMLHttpRequest是个比较粗燥的底层对象，各个浏览器对其的创建方法也不同，以下是兼容方法：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var xhr;</span><br><span class="line">if (window.XMLHttpRequest) &#123; </span><br><span class="line">    // Mozilla, Safari...  </span><br><span class="line">    xhr = new XMLHttpRequest();</span><br><span class="line">&#125; else if (window.ActiveXObject) &#123; </span><br><span class="line">    // IE  </span><br><span class="line">    try &#123;  </span><br><span class="line">    xhr = new ActiveXObject(&apos;Msxml2.XMLHTTP&apos;); </span><br><span class="line">    &#125; catch (e) &#123; </span><br><span class="line">        try &#123;   </span><br><span class="line">            xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);  //IE5,6 </span><br><span class="line">        &#125; catch (e) &#123;&#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用XMLHttpRequest发起一个get请求 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//get请求</span><br><span class="line">xhr.open(&quot;GET&quot;,&quot;test1.txt&quot;,true);xhr.send();</span><br></pre></td></tr></table></figure>

<p>完整的post请求代码如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var xhr;</span><br><span class="line">if (window.XMLHttpRequest) &#123; </span><br><span class="line">    // Mozilla, Safari...  </span><br><span class="line">    xhr = new XMLHttpRequest();</span><br><span class="line">&#125; else if (window.ActiveXObject) &#123;</span><br><span class="line">    // IE  </span><br><span class="line">    try &#123;    </span><br><span class="line">        xhr = new ActiveXObject(&apos;Msxml2.XMLHTTP&apos;); </span><br><span class="line">    &#125; catch (e) &#123; </span><br><span class="line">        try &#123;  </span><br><span class="line">            xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);  </span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;&#125;if (xhr) &#123;</span><br><span class="line">        xhr.onreadystatechange = onReadyStateChange;</span><br><span class="line">        xhr.open(&apos;POST&apos;, &apos;/api&apos;, true);  </span><br><span class="line">        // 设置 Content-Type 为 application/x-www-form-urlencoded  </span><br><span class="line">        // 以表单的形式传递数据  </span><br><span class="line">        xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;); </span><br><span class="line">        xhr.send(&apos;username=admin&amp;password=root&apos;);&#125;</span><br><span class="line">// onreadystatechange 方法</span><br><span class="line">function onReadyStateChange() &#123; </span><br><span class="line">    // 该函数会被调用四次  </span><br><span class="line">    if (xhr.readyState === 4 &amp;&amp;xhr.status === 200) &#123;  </span><br><span class="line">        console.log(&apos;执行成功&apos;);  </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&apos;执行出错&apos;);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Jquery-Ajax"><a href="#Jquery-Ajax" class="headerlink" title="　Jquery Ajax"></a>　<strong>Jquery Ajax</strong></h2><p>说到Jquery，这是一个时代，几乎统治了前端10年有余，彻底解决了UI层与数据层交互的问题，直到三大框架(Angular/React/Vue）的出现，前端进入MVVM浪潮。而Ajax将XHR进行封装，让开发者可以更加便捷方便进行使用。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;   </span><br><span class="line">    //标准写法 </span><br><span class="line">    type: &apos;POST&apos;, </span><br><span class="line">    url: url,   </span><br><span class="line">    data: data, </span><br><span class="line">    dataType: dataType, </span><br><span class="line">    success: function () &#123;&#125;, </span><br><span class="line">    error: function () &#123;&#125;&#125;);</span><br><span class="line">$.get(url,function()&#123;&#125;); </span><br><span class="line">//get请求</span><br><span class="line">$.post(url,body,function()&#123;&#125;);</span><br><span class="line">//post请求</span><br><span class="line">$.getJSON(url,function()&#123;&#125;);  </span><br><span class="line">//get请求从服务器加载Json编码</span><br></pre></td></tr></table></figure>

<p>优点： 对原生XHR的封装 针对MVC的编程 完美的兼容性 支持jsonp</p>
<p> 缺点： 不符合MVVM 异步模型不够现代，不支持链式，代码可读性差 整个Jquery太大，引入成本过高  </p>
<h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a><strong>Fetch</strong></h2><p>fetch其实是一个新世界，脱离的XHR，完全是基于Promise的异步处理机制，使用起来会比起ajax更加简单。 使用fetch的代码会相比xhr来说更具有条理性  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fetch(url).then(function(response) &#123; </span><br><span class="line">    return response.json();&#125;).then(function(data) &#123; </span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;).catch(function(e) &#123; </span><br><span class="line">    console.log(&quot;Oops, error&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在使用ES6的箭头函数后 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(url).then(response =&gt; response.json()) </span><br><span class="line">    .then(data =&gt; console.log(data))</span><br><span class="line">    .catch(e =&gt; console.log(&quot;Oops, error&quot;, e))</span><br></pre></td></tr></table></figure>

<p>优点： 更加底层，提供的API丰富（request, response） 语法简单，脱离了XHR，基于ES新的Promise设计 </p>
<p>看到以上，或许你会觉得fetch真的很美好，但是请了解，fetch本身是一个 low-level 的 API，它注定不会像你习惯的 $.ajax 或是 axios 等库帮你封装各种各样的功能或实现。</p>
<p> 所以它是存在一定的缺点： 兼容性比较凄惨，低级别浏览器均不支持，需要实现fetch的polyfill了。思路其实很简单，就是判断浏览器是否支持原生的fetch，不支持的话，就仍然使用XMLHttpRequest的方式实现，同时结合Promise来进行封装。常见的polyfill就有：es6-promise,babel-polyfill,fetch-ie8等    </p>
<p>不支持jsonp，可以引入fetch-jsonp `javascript //安装 npm install fetch-jsonp –save-dev </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//使用 </span><br><span class="line">fetchJsonp(url, &#123; </span><br><span class="line">    timeout: 3000, </span><br><span class="line">    jsonpCallback: &apos;callback&apos; </span><br><span class="line">&#125;)</span><br><span class="line">    .then(function(response) &#123;</span><br><span class="line">    console.log(response.json());</span><br><span class="line">&#125;)</span><br><span class="line">    .catch(function(e) &#123; </span><br><span class="line">    console.log(e) </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>没有拦截器，需要额外再封装一层或者fetch-interceptor- 默认不带cookie，需要添加配置 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javascriptfetch(url,&#123;  </span><br><span class="line">    credentials: &apos;include&apos; //include表示cookie既可同域，也可跨域，‘same-origin’表示只可同域</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>没有abort，不支持timeout超时处理 可以用Promise.race()实现，Promise.race(iterable) 方法返回一个Promise对象，只要 iterable 中任意一个Promise 被 resolve 或者 reject 后，外部的Promise 就会以相同的值被 resolve 或者 reject。 无法获取progress状态 fetch中的Response.body 中实现了getReader()方法用于读取原始字节流, 该字节流可以循环读取。参考： <a href="https://stackoverflow.com/questions/35711724/upload-progress-indicators-for-fetch" target="_blank" rel="noopener">https://stackoverflow.com/questions/35711724/upload-progress-indicators-for-fetch</a> <a href="https://jakearchibald.com/2016/streams-ftw/" target="_blank" rel="noopener">https://jakearchibald.com/2016/streams-ftw/</a></p>
<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a><strong>Axios</strong></h2><p>axios也是比较新的网络请求的类库，并且被尤雨溪尤大推荐，已成为VUE的网络请求标配，也是十分的火爆。它本身也是对原生XHR的封装。 </p>
<p>支持node，创建http请求 支持Promise API 客户端防止CSRF：每个请求带一个cookie拿到的key 拦截请求和响应 可取消请求 </p>
<p>兼容性上虽然axios本质上也是对原生XHR的封装，但是它也依赖原生ES6 Promise的实现，和fetch一样需要polyfill的兼容。 </p>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//npmnpm install axios</span><br><span class="line">//cdn&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>基本使用如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;    </span><br><span class="line">    method: &apos;GET&apos;,  </span><br><span class="line">    url: url,&#125;)</span><br><span class="line">    .then(res =&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">    .catch(err =&gt; &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;)</span><br><span class="line">// get请求</span><br><span class="line">axios.get(url)  </span><br><span class="line">    .then(function (response) &#123;  </span><br><span class="line">    console.log(response);  </span><br><span class="line">&#125;)  </span><br><span class="line">    .catch(function (error) &#123;  </span><br><span class="line">    console.log(error);  </span><br><span class="line">&#125;);</span><br><span class="line">// post请求</span><br><span class="line">axios.post(‘/user’, &#123;  </span><br><span class="line">    name: &apos;Jerry&apos;, </span><br><span class="line">    lastName: &apos;Liang&apos; </span><br><span class="line">&#125;) </span><br><span class="line">    .then(function (response) &#123; </span><br><span class="line">    console.log(response); </span><br><span class="line">&#125;) </span><br><span class="line">    .catch(function (error) &#123; </span><br><span class="line">    console.log(error); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="特殊场景的处理"><a href="#特殊场景的处理" class="headerlink" title="特殊场景的处理"></a><strong>特殊场景的处理</strong></h2><p>在开发过程中，经常会遇到比较尴尬的场景就是多请求的串行与并发，并发比较容易解决，不存在回调地狱，但是代码可读性就会容易变得很渣，而串行问题对于前端是绝望的，最好的办法是后端来做合并，如果后端不做这块的处理，前端就必须来面对回调地狱  </p>
<h3 id="多请求串行"><a href="#多请求串行" class="headerlink" title="多请求串行"></a><strong>多请求串行</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// ajax</span><br><span class="line">$.ajax(&#123; </span><br><span class="line">    url: &apos;&apos;,</span><br><span class="line">    data: &apos;&apos;,   </span><br><span class="line">    success: function (data) &#123;   </span><br><span class="line">        $.ajax(&#123;       </span><br><span class="line">            url: &apos;&apos;, </span><br><span class="line">            data: &apos;&apos;,      </span><br><span class="line">            success: function (data</span><br><span class="line">            ) &#123;   </span><br><span class="line">                $.ajax(&#123;    </span><br><span class="line">                    // 如此一层嵌套一层    </span><br><span class="line">                &#125;)     </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;)   </span><br><span class="line">    &#125;&#125;)</span><br><span class="line">//axios</span><br><span class="line">axios.get(url).then(res =&gt; &#123; </span><br><span class="line">    return axios.get(url,&#123;  </span><br><span class="line">        &#123;name:result.name&#125;  </span><br><span class="line">                     &#125;);</span><br><span class="line">&#125;).then(res =&gt; &#123;    </span><br><span class="line">    //如此一层层嵌套</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="多请求并行"><a href="#多请求并行" class="headerlink" title="多请求并行"></a><strong>多请求并行</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//ajax 通过计数器实现（虽然Jquery支持$.when的方式，但此处不做案例）</span><br><span class="line">var num = 0;</span><br><span class="line">function all()&#123;  </span><br><span class="line">    num++;   </span><br><span class="line">    if(n&gt;=3)console.log(&apos;三个请求全部完成&apos;)；</span><br><span class="line">&#125;</span><br><span class="line">$.ajax(&#123; </span><br><span class="line">    url: &apos;&apos;, </span><br><span class="line">    data: &apos;&apos;,  </span><br><span class="line">    success: function (data) &#123; </span><br><span class="line">        console.log(&quot;ajax请求1 完成&quot;);  </span><br><span class="line">        all();  </span><br><span class="line">    &#125;&#125;)</span><br><span class="line">$.ajax(&#123;  </span><br><span class="line">    url: &apos;&apos;, </span><br><span class="line">    data: &apos;&apos;,   </span><br><span class="line">    success: function (data) &#123;    </span><br><span class="line">        console.log(&quot;ajax请求2 完成&quot;);   </span><br><span class="line">        all();</span><br><span class="line">    &#125;&#125;)</span><br><span class="line">$.ajax(&#123;  </span><br><span class="line">    url: &apos;&apos;, </span><br><span class="line">    data: &apos;&apos;,  </span><br><span class="line">    success: function (data) &#123;    </span><br><span class="line">        console.log(&quot;ajax请求3 完成&quot;);  </span><br><span class="line">        all();   </span><br><span class="line">    &#125;&#125;)</span><br><span class="line">//axios</span><br><span class="line">function getInfo() &#123; </span><br><span class="line">    return axios.get(url);</span><br><span class="line">&#125;function getUser() &#123; </span><br><span class="line">    return axios.get(url);</span><br><span class="line">&#125;axios.all([getInfo(),</span><br><span class="line">            getUser()]) </span><br><span class="line">    .then(axios.spread(function (info, user) &#123;   </span><br><span class="line">    // 两个请求现在都执行完成 </span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/22/简述Js原型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/22/简述Js原型/" itemprop="url">简述Js原型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-22T13:01:55+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简述Js中的原型与原型链"><a href="#简述Js中的原型与原型链" class="headerlink" title="简述Js中的原型与原型链"></a>简述Js中的原型与原型链</h1><h2 id="1、原型"><a href="#1、原型" class="headerlink" title="1、原型"></a>1、原型</h2><p>Javascript是基于对象的编程语言，他其中也含有部分封装、继承的概念，而原型概念便是基于继承的。</p>
<p> 函数的原型类似于面向对象语言中子类的父类，而函数本身类似于子类。函数继承了函数原型中的属性和方法，即函数本身可以调用它原型中的属性和方法。</p>
<p> 知识点：若有函数Person，则它的函数原型为Person.prototype，函数原型本身是个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的例子中涉及到了 构造函数、对象和函数原型，接下来给出三者之间的关系图； </p>
<h2 id="2、构造函数、实例、原型三者之间的关系"><a href="#2、构造函数、实例、原型三者之间的关系" class="headerlink" title="2、构造函数、实例、原型三者之间的关系"></a>2、构造函数、实例、原型三者之间的关系</h2><p><img src="//yoursite.com/2019/07/22/简述Js原型/%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB.png" alt="三者关系"></p>
<p>由图中我们可以很直观的看到三者之间的关系。</p>
<p>p对象由Person构造函数构造</p>
<p>p对象通过<strong>proto</strong>属性访问到Person对象原型</p>
<p>Person对象原型通过constructor访问Person构造函数</p>
<p>Person函数通过prototype属性访问到Person原型对象</p>
<p>注意：对象是通过<strong>proto</strong>属性访问对象原型，函数是通过prototype访问对象原型，但两者访问到的对象原型是同一个</p>
<p>验证：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>constructor的作用：可以使得对象访问到对应的构造函数 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>知道以上的知识之后，我们还要了解，其实Person的原型也有原型，即存在Person.prototype.prototype，并且它是Person.prototype的原型，可以用图来直观了解这其中的关系，这便是一个简单的原型链。 </p>
<h2 id="3、原型链"><a href="#3、原型链" class="headerlink" title="3、原型链"></a>3、原型链</h2><p>​     <img src="//yoursite.com/2019/07/22/简述Js原型/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"></p>
<p>% asset_img 三者关系.png This is an test image %</p>
<h2 id="4、原型链中的搜索规则"><a href="#4、原型链中的搜索规则" class="headerlink" title="4、原型链中的搜索规则"></a>4、原型链中的搜索规则</h2><p>了解了 <strong>构造函数-实例-原型对象</strong> 三者之间的关系后，接下来我们来解释一下为什么实例对象可以访问原型对象中的成员。</p>
<p>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性</p>
<ul>
<li>搜索首先从对象实例本身开始</li>
<li>如果在实例中找到了具有给定名字的属性，则返回该属性的值</li>
<li>如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性</li>
<li>如果在原型对象中找到了这个属性，则返回该属性的值</li>
</ul>
<p>也就是说，在我们调用 <code>p.sayName()</code> 的时候，会先后执行两次搜索：</p>
<ul>
<li>首先，解析器会问：“实例 p 有 sayName 属性吗？”答：“没有。</li>
<li>”然后，它继续搜索，再问：“ p 的原型有 sayName 属性吗？”答：“有。</li>
<li>”于是，它就读取那个保存在原型对象中的函数。</li>
</ul>
<p>而这正是多个对象实例共享原型所保存的属性和方法的基本原理。</p>
<p>总结：</p>
<ul>
<li>先在自己身上找，找到即返回</li>
<li>自己身上找不到，则沿着原型链向上查找，找到即返回</li>
<li>如果一直到原型链的末端还没有找到，则返回 <code>undefined</code></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/13/JS中this的指向/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/13/JS中this的指向/" itemprop="url">JS中this的指向</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-13T12:18:23+08:00">
                2019-07-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先，必须搞清楚在JS里面，函数的几种调用方式: 普通函数调用 作为方法来调用 作为构造函数来调用 使用apply/call方法来调用 Function.prototype.bind方法 es6箭头函数 但是不管函数是按哪种方法来调用的，请记住一点：谁调用这个函数或方法,this关键字就指向谁。 接下来就分情况来讨论下这些不同的情况：</p>
<h3 id="一-普通函数调用"><a href="#一-普通函数调用" class="headerlink" title="一.普通函数调用"></a>一.普通函数调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function person()&#123;</span><br><span class="line">    this.name=&quot;xiaohei&quot;;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person();  //输出  window  xiaohei</span><br></pre></td></tr></table></figure>

<p>在这段代码中person函数作为普通函数调用，实际上person是作为全局对象window的一个方法来进行调用的,即window.person(); 所以这个地方是window对象调用了person方法,那么person函数当中的this即指window,同时window还拥有了另外一个属性name,值为xiaohei</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var name=&quot;xiaobai&quot;;</span><br><span class="line">function person()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">person(); //输出 xiaobai</span><br></pre></td></tr></table></figure>

<p>同样这个地方person作为window的方法来调用，在代码的一开始定义了一个全局变量name，值为xiaobai,它相当于window的一个属性,即window.name=”xiaobai”,又因为在调用person的时候this是指向window的，因此这里会输出xiaobai  </p>
<h3 id="二-作为方法来调用"><a href="#二-作为方法来调用" class="headerlink" title="二.作为方法来调用"></a>二.作为方法来调用</h3><p>在上面的代码中，普通函数的调用即是作为window对象的方法进行调用。显然this关键字指向了window对象. </p>
<p>再来看下其他的形式 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> var name=&quot;XL&quot;;</span><br><span class="line"> var person=&#123;</span><br><span class="line">     name:&quot;xl&quot;,</span><br><span class="line">     showName:function()&#123;</span><br><span class="line">         console.log(this.name);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> person.showName();  //输出  xl</span><br><span class="line">//这里是person对象调用showName方法，很显然this关键字是指向person对象的，所以会输出name</span><br><span class="line"> </span><br><span class="line"> var showNameA=person.showName;</span><br><span class="line"> showNameA();    //输出  XL</span><br><span class="line"> //这里将person.showName方法赋给showNameA变量，此时showNameA变量相当于window对象的一个属性，因此showNameA()执行的时候相当于window.showNameA(),即window对象调用showNameA这个方法，所以this关键字指向window</span><br></pre></td></tr></table></figure>

<p>再换种形式： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var personA=&#123;</span><br><span class="line">    name:&quot;xl&quot;,</span><br><span class="line">    showName:function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var personB=&#123;</span><br><span class="line">    name:&quot;XL&quot;,</span><br><span class="line">    sayName:personA.showName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">personB.sayName();  //输出 XL</span><br><span class="line">//虽然showName方法是在personA这个对象中定义，但是调用的时候却是在personB这个对象中调用，因此this对象指向</span><br></pre></td></tr></table></figure>

<h3 id="三-作为构造函数来调用"><a href="#三-作为构造函数来调用" class="headerlink" title="三.作为构造函数来调用"></a>三.作为构造函数来调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function  Person(name)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">&#125;</span><br><span class="line">var personA=Person(&quot;xl&quot;);   </span><br><span class="line">console.log(personA.name); // 输出  undefined</span><br><span class="line">console.log(window.name);//输出  xl</span><br><span class="line"> //上面代码没有进行new操作，相当于window对象调用Person(&quot;xl&quot;)方法，那么this指向window对象，并进行赋值操作window.name=&quot;xl&quot;.</span><br><span class="line"> </span><br><span class="line">var personB=new Person(&quot;xl&quot;);</span><br><span class="line">console.log(personB.name);// 输出 xl</span><br><span class="line">//这部分代码的解释见下</span><br></pre></td></tr></table></figure>

<h5 id="1-new操作符"><a href="#1-new操作符" class="headerlink" title="1.new操作符"></a>1.new操作符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//下面这段代码模拟了new操作符(实例化对象)的内部过程</span><br><span class="line">  function person(name)&#123;</span><br><span class="line">      var o=&#123;&#125;;</span><br><span class="line">      o.__proto__=Person.prototype;  //原型继承</span><br><span class="line">      Person.call(o,name);</span><br><span class="line">      return o;</span><br><span class="line">  &#125;</span><br><span class="line">  var personB=person(&quot;xl&quot;);</span><br><span class="line">  </span><br><span class="line">  console.log(personB.name);  // 输出  xl</span><br></pre></td></tr></table></figure>

<p>在person里面首先创建一个空对象o，将o的proto指向Person.prototype完成对原型的属性和方法的继承 Person.call(o,name)这里即函数Person作为apply/call调用(具体内容下方)，将Person对象里的this改为o，即完成了o.name=name操作 返回对象o。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因此`person(&quot;xl&quot;)`返回了一个继承了`Person.prototype`对象上的属性和方法，以及拥有`name`属性为&quot;xl&quot;的对象，并将它赋给变量`personB`.</span><br><span class="line">所以`console.log(personB.name)`会输出&quot;xl&quot;</span><br></pre></td></tr></table></figure>

<h5 id="2-call-apply方法的调用"><a href="#2-call-apply方法的调用" class="headerlink" title="2..call/apply方法的调用"></a>2..call/apply方法的调用</h5><p> 在JS里函数也是对象，因此函数也有方法。从Function.prototype上继承到Function.prototype.call/Function.prototype.apply方法 call/apply方法最大的作用就是能改变this关键字的指向.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Obj.method.apply(AnotherObj,arguments);</span><br><span class="line"></span><br><span class="line">  var name=&quot;XL&quot;;</span><br><span class="line">     var Person=&#123;</span><br><span class="line">        name:&quot;xl&quot;,</span><br><span class="line">         showName:function()&#123;</span><br><span class="line">             console.log(this.name);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     Person.showName.call(); //输出 &quot;XL&quot;</span><br><span class="line">     //这里call方法里面的第一个参数为空，默认指向window。</span><br><span class="line">     //虽然showName方法定义在Person对象里面，但是使用call方法后，将showName方法里面的this指向了window。因此最后会输出&quot;XL&quot;;</span><br><span class="line">    funtion FruitA(n1,n2)&#123;</span><br><span class="line">         this.n1=n1;</span><br><span class="line">         this.n2=n2;</span><br><span class="line">         this.change=function(x,y)&#123;</span><br><span class="line">             this.n1=x;</span><br><span class="line">             this.n2=y;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     var fruitA=new FruitA(&quot;cheery&quot;,&quot;banana&quot;);</span><br><span class="line">     var FruitB=&#123;</span><br><span class="line">         n1:&quot;apple&quot;,</span><br><span class="line">         n2:&quot;orange&quot;</span><br><span class="line">     &#125;;</span><br><span class="line">     fruitA.change.call(FruitB,&quot;pear&quot;,&quot;peach&quot;);</span><br><span class="line">     </span><br><span class="line">     console.log(FruitB.n1); //输出 pear</span><br><span class="line">     console.log(FruitB.n2);// 输出 peach</span><br></pre></td></tr></table></figure>

<p>FruitB调用fruitA的change方法，将fruitA中的this绑定到对象FruitB上。</p>
<h5 id="3-Function-prototype-bind-方法"><a href="#3-Function-prototype-bind-方法" class="headerlink" title="3.Function.prototype.bind()方法"></a>3.Function.prototype.bind()方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var name=&quot;XL&quot;;</span><br><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.sayName=function()&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&quot;my name is &quot;+this.name);</span><br><span class="line">        &#125;,50)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person=new Person(&quot;xl&quot;);</span><br><span class="line">person.sayName()  //输出  “my name is XL”;</span><br><span class="line">                   //这里的setTimeout()定时函数,相当于window.setTimeout(),由window这个全局对象对调用,因此this的指向为window, 则this.name则为XL</span><br></pre></td></tr></table></figure>

<p>那么如何才能输出<code>&quot;my name is xl&quot;</code>呢？ </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name=&quot;XL&quot;;</span><br><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.sayName=function()&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&quot;my name is &quot;+this.name);</span><br><span class="line">        &#125;.bind(this),50)  //注意这个地方使用的bind()方法，绑定setTimeout里面的匿名函数的this一直指向Person对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person=new Person(&quot;xl&quot;);</span><br><span class="line">person.sayName(); //输出 “my name is xl”;</span><br></pre></td></tr></table></figure>

<p>这里setTimeout(function(){console.log(this.name)}.bind(this),50);,匿名函数使用bind(this)方法后创建了新的函数，这个新的函数不管在什么地方执行，this都指向的Person,而非window,因此最后的输出为”my name is xl”而不是”my name is XL” 另外几个需要注意的地方： setTimeout/setInterval/匿名函数执行的时候，this默认指向window对象，除非手动改变this的指向。在《javascript高级程序设计》当中，写到：“超时调用的代码(setTimeout)都是在全局作用域中执行的，因此函数中的this的值，在非严格模式下是指向window对象，在严格模式下是指向undefined”。本文都是在非严格模式下的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var name=&quot;XL&quot;;</span><br><span class="line">  function Person()&#123;</span><br><span class="line">      this.name=&quot;xl&quot;;</span><br><span class="line">      this.showName=function()&#123;</span><br><span class="line">          console.log(this.name);</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(this.showName,50);</span><br><span class="line">  &#125;</span><br><span class="line">  var person=new Person(); //输出 &quot;XL&quot;</span><br><span class="line">  </span><br><span class="line">  //在setTimeout(this.showName,50)语句中，会延时执行this.showName方法</span><br><span class="line">  //this.showName方法即构造函数Person()里面定义的方法。50ms后，执行this.showName方法，this.showName里面的this此时便指向了window对象。则会输出&quot;XL&quot;;</span><br></pre></td></tr></table></figure>

<p>修改上面的代码： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var name=&quot;XL&quot;;</span><br><span class="line">   function Person()&#123;</span><br><span class="line">      this.name=&quot;xl&quot;;</span><br><span class="line">      var that=this;</span><br><span class="line">      this.showName=function()&#123;</span><br><span class="line">         console.log(that.name);</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(this.showName,50)</span><br><span class="line"> &#125;</span><br><span class="line"> var person=new Person(); //输出 &quot;xl&quot;</span><br><span class="line"> </span><br><span class="line">//这里在Person函数当中将this赋值给that，即让that保存Person对象，因此在setTimeout(this.showName,50)执行过程当中，console.log(that.name)即会输出Person对象的属性&quot;xl&quot;</span><br></pre></td></tr></table></figure>

<p>匿名函数： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var name=&quot;XL&quot;;</span><br><span class="line">  var person=&#123;</span><br><span class="line">      name:&quot;xl&quot;,</span><br><span class="line">      showName:function()&#123;</span><br><span class="line">          console.log(this.name);</span><br><span class="line">      &#125;</span><br><span class="line">      sayName:function()&#123;</span><br><span class="line">          (function(callback)&#123;</span><br><span class="line">            callback();</span><br><span class="line">         &#125;)(this.showName)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> person.sayName();  //输出 XL</span><br><span class="line"> var name=&quot;XL&quot;;</span><br><span class="line"> var person=&#123;</span><br><span class="line">     name:&quot;xl&quot;,</span><br><span class="line">     showName:function()&#123;</span><br><span class="line">         console.log(this.name);</span><br><span class="line">     &#125;</span><br><span class="line">     sayName:function()&#123;</span><br><span class="line">         var that=this;</span><br><span class="line">         (function(callback)&#123;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;)(that.showName)</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> person.sayName() ;  //输出  &quot;xl&quot;</span><br><span class="line">//匿名函数的执行同样在默认情况下this是指向window的，除非手动改变this的绑定对象</span><br></pre></td></tr></table></figure>

<h3 id="四-箭头函数"><a href="#四-箭头函数" class="headerlink" title="四.箭头函数"></a>四.箭头函数</h3><p>es6里面this指向固定化，始终指向外部对象，因为箭头函数没有this,因此它自身不能进行new实例化,同时也不能使用call, apply, bind等方法来改变this的指向 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Timer() &#123;</span><br><span class="line">     this.seconds = 0;</span><br><span class="line">     setInterval( () =&gt; this.seconds ++, 1000);</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> var timer = new Timer();</span><br><span class="line"> </span><br><span class="line"> setTimeout( () =&gt; console.log(timer.seconds), 3100);</span><br><span class="line"> </span><br><span class="line"> // 3</span><br><span class="line">// 在构造函数内部的setInterval()内的回调函数，this始终指向实例化的对象，并获取实例化对象的seconds的属性,每1s这个属性的值都会增加1。否则最后在3s后执行setTimeOut()函数执行后输出的是0</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
